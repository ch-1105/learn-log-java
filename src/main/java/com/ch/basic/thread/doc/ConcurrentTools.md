# Java并发工具类详解

## 1. CountDownLatch

### 1.1 基本概念
- 允许一个或多个线程等待其他线程完成操作
- 计数器初始化为N，每完成一个任务计数减1
- 当计数为0时，等待的线程被释放
- 计数器不能重置

### 1.2 主要方法
- `countDown()`：计数器减1
- `await()`：等待计数器归零
- `await(long timeout, TimeUnit unit)`：限时等待

### 1.3 使用场景
1. **并行任务同步点**
   - 等待所有任务完成后再继续
   - 多个子任务完成后汇总结果

2. **服务依赖检查**
   - 等待依赖的服务启动
   - 确保所有前置条件满足

## 2. CyclicBarrier

### 2.1 基本概念
- 允许多个线程互相等待，到达同步点
- 计数器可以重置，可重复使用
- 可以在同步点执行预定义的操作
- 所有线程必须同时到达才能继续

### 2.2 主要方法
- `await()`：等待其他线程
- `await(long timeout, TimeUnit unit)`：限时等待
- `reset()`：重置屏障
- `getNumberWaiting()`：获取当前等待的线程数
- `isBroken()`：检查屏障是否被破坏

### 2.3 使用场景
1. **并行迭代计算**
   - 并行计算分阶段任务
   - 游戏多玩家同步

2. **数据库分片处理**
   - 多个分片数据并行处理
   - 等待所有分片处理完成

## 3. Semaphore

### 3.1 基本概念
- 控制同时访问特定资源的线程数量
- 可以用于流量控制
- 支持公平和非公平模式
- 可以动态添加许可证

### 3.2 主要方法
- `acquire()`：获取许可
- `release()`：释放许可
- `tryAcquire()`：尝试获取许可
- `availablePermits()`：当前可用许可数
- `drainPermits()`：获取并返回所有可用许可

### 3.3 使用场景
1. **资源池限流**
   - 数据库连接池
   - 线程池限流
   - API限流

2. **并发访问控制**
   - 停车场车位管理
   - 并发请求限制

## 4. 工具类对比

### 4.1 CountDownLatch vs CyclicBarrier
1. **重用性**
   - CountDownLatch：一次性使用
   - CyclicBarrier：可重复使用

2. **等待方式**
   - CountDownLatch：一个或多个线程等待其他线程
   - CyclicBarrier：多个线程互相等待

3. **计数器操作**
   - CountDownLatch：减操作
   - CyclicBarrier：等待操作

### 4.2 Semaphore特点
1. **灵活性**
   - 可动态增减许可数
   - 支持公平/非公平模式
   - 可以一次获取多个许可

2. **使用方式**
   - 必须手动释放许可
   - 支持尝试获取许可
   - 可以查询可用许可数

## 5. 最佳实践

### 5.1 CountDownLatch最佳实践
1. **合理设置计数值**
2. **使用try-finally确保countDown()**
3. **考虑使用超时等待**
4. **注意线程中断处理**

### 5.2 CyclicBarrier最佳实践
1. **处理异常情况**
2. **合理使用重置功能**
3. **注意避免死锁**
4. **合理设置超时时间**

### 5.3 Semaphore最佳实践
1. **正确释放许可**
2. **合理设置许可数量**
3. **使用tryAcquire避免死锁**
4. **注意公平性的影响**

## 6. 面试常见问题

### 6.1 基础概念
1. CountDownLatch和CyclicBarrier的区别？
2. Semaphore的实现原理？
3. 如何处理并发工具类的异常情况？

### 6.2 实践应用
1. 什么场景下使用CountDownLatch？
2. CyclicBarrier的实际应用场景？
3. Semaphore如何用于限流？

### 6.3 原理深入
1. 这些工具类是如何实现的？
2. 它们与AQS的关系？
3. 性能和注意事项？
