# Java虚拟机（JVM）架构详解

## 一、JVM整体架构

### 1.1 JVM的核心组成部分
```
  ┌─────────────────────────────────────────┐
  │            类装载子系统                  │
  └─────────────────────────────────────────┘
           ↓                    ↓
┌─────────────────┐  ┌──────────────────────┐
│   方法区(元空间) │  │      Java堆         │
└─────────────────┘  └──────────────────────┘
           ↓                    ↓
┌─────────────────┐  ┌──────────────────────┐
│    本地方法栈   │  │       虚拟机栈       │
└─────────────────┘  └──────────────────────┘
           ↓                    ↓
┌─────────────────────────────────────────┐
│               程序计数器                 │
└─────────────────────────────────────────┘
           ↓                    ↓
┌─────────────────────────────────────────┐
│            执行引擎                      │
└─────────────────────────────────────────┘
```

### 1.2 运行时数据区
1. **程序计数器（Program Counter Register）**
   - 当前线程执行字节码的行号指示器
   - 线程私有
   - 唯一一个在JVM规范中没有规定任何OutOfMemoryError的区域

2. **Java虚拟机栈（Java Virtual Machine Stack）**
   - 线程私有
   - 存储局部变量表、操作数栈、动态链接、方法出口等信息
   - 可能抛出StackOverflowError和OutOfMemoryError

3. **本地方法栈（Native Method Stack）**
   - 线程私有
   - 为虚拟机使用到的Native方法服务
   - 可能抛出StackOverflowError和OutOfMemoryError

4. **Java堆（Java Heap）**
   - 线程共享
   - 存放对象实例
   - 垃圾收集器管理的主要区域
   - 可能抛出OutOfMemoryError

5. **方法区（Method Area）/元空间（Metaspace）**
   - 线程共享
   - 存储已被虚拟机加载的类信息、常量、静态变量等
   - JDK8后使用本地内存实现的元空间替代永久代

## 二、内存模型（JMM）

### 2.1 主内存与工作内存
```
  ┌─────────────────────────────────────┐
  │            主内存（Main Memory）      │
  └─────────────────────────────────────┘
     ↑          ↑          ↑          ↑
     │          │          │          │
┌────┴───┐ ┌────┴───┐ ┌────┴───┐ ┌────┴───┐
│工作内存 │ │工作内存 │ │工作内存 │ │工作内存 │
└────┬───┘ └────┬───┘ └────┬───┘ └────┬───┘
     │          │          │          │
┌────┴───┐ ┌────┴───┐ ┌────┴───┐ ┌────┴───┐
│ 线程1  │ │ 线程2  │ │ 线程3  │ │ 线程4  │
└────────┘ └────────┘ └────────┘ └────────┘
```

### 2.2 内存交互操作
- **lock（锁定）**：作用于主内存变量
- **unlock（解锁）**：作用于主内存变量
- **read（读取）**：作用于主内存变量
- **load（载入）**：作用于工作内存变量
- **use（使用）**：作用于工作内存变量
- **assign（赋值）**：作用于工作内存变量
- **store（存储）**：作用于工作内存变量
- **write（写入）**：作用于主内存变量

### 2.3 内存模型三大特性
1. **原子性（Atomicity）**
   - 基本数据类型的读写是原子的
   - synchronized和Lock提供的原子性保证
   - java.util.concurrent.atomic包

2. **可见性（Visibility）**
   - volatile关键字
   - synchronized的可见性保证
   - final的可见性

3. **有序性（Ordering）**
   - happens-before原则
   - volatile的禁止重排序
   - synchronized的有序性保证

## 三、类加载机制

### 3.1 类加载的生命周期
```
加载 → 验证 → 准备 → 解析 → 初始化 → 使用 → 卸载
      ├───────链接───────┤
```

1. **加载（Loading）**
   - 通过类的全限定名获取二进制字节流
   - 将字节流所代表的静态存储结构转化为方法区的运行时数据结构
   - 在内存中生成Class对象

2. **验证（Verification）**
   - 文件格式验证
   - 元数据验证
   - 字节码验证
   - 符号引用验证

3. **准备（Preparation）**
   - 为类变量分配内存
   - 设置类变量初始值

4. **解析（Resolution）**
   - 将常量池内的符号引用替换为直接引用

5. **初始化（Initialization）**
   - 执行类构造器<clinit>()方法
   - 为类的静态变量赋予正确的初始值

### 3.2 类加载器
1. **启动类加载器（Bootstrap ClassLoader）**
   - 负责加载JDK的核心类库
   - 如rt.jar、resources.jar等

2. **扩展类加载器（Extension ClassLoader）**
   - 负责加载JDK的扩展目录（jre/lib/ext）下的jar包

3. **应用程序类加载器（Application ClassLoader）**
   - 负责加载用户类路径（classpath）下的类库

4. **自定义类加载器（User ClassLoader）**
   - 通过继承ClassLoader实现
   - 可以实现特殊的类加载需求

### 3.3 双亲委派模型
```
       Bootstrap ClassLoader
              ↑
       Extension ClassLoader
              ↑
     Application ClassLoader
              ↑
        User ClassLoader
```

工作流程：
1. 收到类加载请求
2. 把请求委派给父加载器完成
3. 父加载器无法完成时才自己加载

优点：
- 避免类的重复加载
- 保证Java核心库的类型安全
- 保证Java核心类库所提供的类不会被篡改

## 四、即将展开的内容

1. **垃圾回收机制**
   - 垃圾回收算法
   - 垃圾收集器
   - GC调优

2. **JVM调优**
   - JVM参数详解
   - 性能监控与故障处理
   - 调优案例分析

3. **实战示例**
   - 内存溢出分析
   - 线程死锁分析
   - 性能调优实践
