# Java对象内存布局详解

## 一、对象的内存布局概述

Java对象在内存中的存储布局可以分为三个区域：
```
┌─────────────────┐
│    对象头       │ Object Header
├─────────────────┤
│    实例数据     │ Instance Data
├─────────────────┤
│    对齐填充     │ Padding
└─────────────────┘
```

## 二、对象头（Object Header）

### 2.1 Mark Word
- **长度**：32位JVM中为32bit，64位JVM中为64bit
- **内容**：存储对象自身的运行时数据
  ```
  ┌───────────────────────────────────────────────────┐
  │                    Mark Word (64 bits)            │
  ├───────────────────────────────────────────────────┤
  │      状态        │              存储内容           │
  ├─────────────────┼───────────────────────────────┤
  │  未锁定         │ 对象哈希码、年龄、是否偏向锁    │
  │  轻量级锁定     │ 指向栈中锁记录的指针           │
  │  重量级锁定     │ 指向互斥量（重量级锁）的指针    │
  │  GC标记         │ 空，不需要记录信息             │
  │  偏向锁         │ 线程ID、偏向时间戳、年龄等      │
  └─────────────────┴───────────────────────────────┘
  ```

### 2.2 类型指针（Class Pointer）
- 指向对象的类元数据的指针
- 通过这个指针可以确定对象是哪个类的实例
- 如果开启了压缩指针（-XX:+UseCompressedOops），则占用4字节，否则占用8字节

## 三、实例数据（Instance Data）

### 3.1 数据存储规则
1. **继承规则**：父类中定义的变量会出现在子类之前
2. **类型长度**：按照长度由长到短排序
3. **引用类型**：最后放置所有的引用类型

### 3.2 基本数据类型占用空间
```
┌─────────────┬──────────┐
│  数据类型    │  占用字节 │
├─────────────┼──────────┤
│  boolean    │    1     │
│  byte       │    1     │
│  short      │    2     │
│  char       │    2     │
│  int        │    4     │
│  float      │    4     │
│  long       │    8     │
│  double     │    8     │
│  reference  │   4/8    │
└─────────────┴──────────┘
```

### 3.3 数据对齐
- 每个变量的存储起始地址必须是其类型大小的整数倍
- 如果不对齐，需要进行填充

## 四、对齐填充（Padding）

### 4.1 为什么需要对齐填充？
1. **性能考虑**：CPU访问对齐的数据更高效
2. **HotSpot规范**：对象大小必须是8字节的整数倍

### 4.2 对齐规则
- 对象的起始地址必须是8字节的整数倍
- 实例数据部分的每个字段必须对齐到其自身大小的整数倍地址

## 五、实际案例分析

### 5.1 普通对象布局
```java
class SimpleObject {
    private int value;     // 4字节
    private long data;     // 8字节
    private byte flag;     // 1字节
}
```
内存布局（64位JVM，开启压缩指针）：
```
┌────────────────────┐
│      Mark Word     │ 8字节
├────────────────────┤
│    类型指针        │ 4字节
├────────────────────┤
│      value        │ 4字节
├────────────────────┤
│      data         │ 8字节
├────────────────────┤
│      flag         │ 1字节
├────────────────────┤
│      填充         │ 7字节
└────────────────────┘
总大小：32字节
```

### 5.2 数组对象布局
```java
int[] array = new int[3];
```
内存布局（64位JVM，开启压缩指针）：
```
┌────────────────────┐
│      Mark Word     │ 8字节
├────────────────────┤
│    类型指针        │ 4字节
├────────────────────┤
│    数组长度        │ 4字节
├────────────────────┤
│    数组数据        │ 12字节（3个int）
├────────────────────┤
│      填充         │ 4字节
└────────────────────┘
总大小：32字节
```

## 六、实践建议

### 6.1 内存占用优化
1. **合理排列字段顺序**
   - 按照字段大小排序可以减少填充
   - 将相同类型的字段放在一起

2. **使用压缩指针**
   - 开启-XX:+UseCompressedOops可以减少内存占用
   - 适用于堆内存小于32GB的情况

3. **注意对象大小**
   - 对象越小，GC压力越小
   - 避免不必要的实例字段

### 6.2 性能优化
1. **缓存行对齐**
   - 考虑将热点字段按照缓存行大小（64字节）对齐
   - 避免伪共享问题

2. **对象池化**
   - 对于频繁创建的小对象，考虑使用对象池
   - 减少GC压力

3. **使用基本类型**
   - 优先使用基本类型而不是包装类型
   - 减少对象引用带来的内存开销
