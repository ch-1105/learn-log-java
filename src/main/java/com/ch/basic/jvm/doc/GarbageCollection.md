# Java垃圾回收机制详解

## 一、垃圾回收基础

### 1.1 什么是垃圾
- 程序中已经没有任何引用指向的对象
- 超出作用域或被显式设置为null的对象

### 1.2 判断对象是否可回收

#### 引用计数法
```java
Object obj = new Object(); // 引用计数+1
obj = null;               // 引用计数-1
```
- **优点**：实现简单，判定效率高
- **缺点**：无法解决循环引用问题

#### 可达性分析
```
┌─────────────┐
│  GC Roots   │
└─────────────┘
       ↓
┌─────────────┐     ┌─────────────┐
│   对象1      │ →  │   对象2      │
└─────────────┘     └─────────────┘
       ↓
┌─────────────┐
│   对象3      │
└─────────────┘
```

**GC Roots包括：**
1. 虚拟机栈中引用的对象
2. 方法区中静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中JNI引用的对象

## 二、垃圾回收算法

### 2.1 标记-清除算法（Mark-Sweep）
```
标记前：
[O][O][X][O][X][O][O][X]
标记后：
[O][O][_][O][_][O][O][_]
```
- **优点**：实现简单
- **缺点**：
  1. 效率不高
  2. 会产生大量内存碎片

### 2.2 复制算法（Copying）
```
复制前：
From空间：[O][O][X][O][X][O][O][X]
To空间：  [_][_][_][_][_][_][_][_]

复制后：
From空间：[_][_][_][_][_][_][_][_]
To空间：  [O][O][O][O][_][_][_][_]
```
- **优点**：效率高，无碎片
- **缺点**：内存利用率低

### 2.3 标记-整理算法（Mark-Compact）
```
标记整理前：
[O][O][X][O][X][O][O][X]
标记整理后：
[O][O][O][O][_][_][_][_]
```
- **优点**：无碎片，内存利用率高
- **缺点**：移动对象成本高

### 2.4 分代收集算法
```
┌─────────────────────────────┐
│           堆内存            │
├───────────────┬─────────────┤
│    新生代      │   老年代    │
├────────┬──────┤             │
│ Eden   │Survivor│            │
└────────┴──────┴─────────────┘
```
- **新生代**：复制算法
- **老年代**：标记-整理算法

## 三、垃圾收集器

### 3.1 新生代收集器
1. **Serial收集器**
   - 单线程
   - 简单高效
   - Client模式下默认收集器

2. **ParNew收集器**
   - Serial的多线程版本
   - Server模式下首选新生代收集器

3. **Parallel Scavenge收集器**
   - 关注吞吐量
   - 可以自适应调节

### 3.2 老年代收集器
1. **Serial Old收集器**
   - Serial的老年代版本
   - 单线程标记-整理算法

2. **Parallel Old收集器**
   - Parallel Scavenge的老年代版本
   - 多线程标记-整理算法

3. **CMS收集器**
   - 最短停顿时间为目标
   - 标记-清除算法
   ```
   初始标记 → 并发标记 → 重新标记 → 并发清除
   ```

4. **G1收集器**
   - 面向服务端应用的收集器
   - 可预测的停顿时间模型
   ```
   ┌────┬────┬────┬────┐
   │ E  │ S  │ O  │ H  │
   ├────┼────┼────┼────┤
   │ H  │ O  │ O  │ H  │
   ├────┼────┼────┼────┤
   │ E  │ O  │ E  │ S  │
   └────┴────┴────┴────┘
   E-Eden, S-Survivor, O-Old, H-Humongous
   ```

## 四、GC调优

### 4.1 常用JVM参数
```bash
# 堆大小设置
-Xms : 初始堆大小
-Xmx : 最大堆大小
-Xmn : 新生代大小

# 收集器设置
-XX:+UseSerialGC : Serial + Serial Old
-XX:+UseParNewGC : ParNew + Serial Old
-XX:+UseParallelGC : Parallel Scavenge + Serial Old
-XX:+UseParallelOldGC : Parallel Scavenge + Parallel Old
-XX:+UseConcMarkSweepGC : ParNew + CMS + Serial Old
-XX:+UseG1GC : G1收集器

# GC日志
-XX:+PrintGCDetails : 打印GC详细信息
-XX:+PrintGCTimeStamps : 打印GC时间戳
```

### 4.2 调优目标
1. **降低GC频率**
2. **减少GC停顿时间**
3. **提高吞吐量**

### 4.3 调优策略
1. **选择合适的收集器**
2. **调整内存大小**
3. **调整代空间比例**
4. **调整GC触发时机**

## 五、内存泄漏分析

### 5.1 常见内存泄漏场景
1. **集合类泄漏**
2. **单例模式泄漏**
3. **内部类持有外部类引用**
4. **资源未关闭**
5. **ThreadLocal使用不当**

### 5.2 排查工具
1. **jstat**: 虚拟机统计信息
2. **jmap**: 堆内存快照
3. **jhat**: 堆快照分析
4. **MAT**: Eclipse Memory Analyzer

### 5.3 排查步骤
1. 观察GC日志
2. 获取堆转储
3. 分析对象引用链
4. 定位泄漏源
5. 验证解决方案
