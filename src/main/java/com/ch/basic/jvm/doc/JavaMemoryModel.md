# Java内存模型（JMM）详解

## 一、JMM基本概念

### 1.1 为什么需要JMM？
在并发编程中存在两个关键问题：
1. **线程间如何通信？** - 线程之间以何种方式来交换信息
2. **线程间如何同步？** - 如何保证线程间操作的有序性

JMM是Java定义的并发编程内存模型，解决了以下问题：
- 定义了共享内存系统中多线程程序读写操作行为的规范
- 屏蔽了各种硬件和操作系统的内存访问差异

### 1.2 JMM的抽象结构
```
┌─────────────────────────────────────┐
│            主内存（Main Memory）      │
│  共享变量：instance, count等         │
└─────────────────────────────────────┘
          ↑↓          ↑↓
┌─────────────┐  ┌─────────────┐
│  本地内存1   │  │  本地内存2   │
│  线程1私有   │  │  线程2私有   │
└─────────────┘  └─────────────┘
      ↑↓              ↑↓
┌─────────────┐  ┌─────────────┐
│   线程1     │  │    线程2    │
└─────────────┘  └─────────────┘
```

## 二、内存交互操作

### 2.1 八种原子操作
1. **lock（锁定）**：作用于主内存，将变量标识为线程独占状态
2. **unlock（解锁）**：作用于主内存，将变量从独占状态释放出来
3. **read（读取）**：作用于主内存，将变量值从主内存传输到线程的工作内存
4. **load（载入）**：作用于工作内存，将read到的值放入工作内存的变量副本中
5. **use（使用）**：作用于工作内存，将工作内存中的值传递给执行引擎
6. **assign（赋值）**：作用于工作内存，将执行引擎的值赋给工作内存的变量
7. **store（存储）**：作用于工作内存，将工作内存的值传送到主内存
8. **write（写入）**：作用于主内存，将store的值放到主内存的变量中

### 2.2 操作规则
1. 不允许read和load、store和write操作之一单独出现
2. 不允许一个线程丢弃它的最近assign的操作
3. 不允许一个线程无原因地（没有发生过assign操作）把数据从工作内存同步回主内存
4. 一个新的变量只能在主内存中诞生
5. 一个变量同一时刻只允许一条线程对其进行lock操作
6. 如果对一个变量执行lock操作，将会清空工作内存中此变量的值
7. 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）

## 三、内存模型三大特性

### 3.1 原子性（Atomicity）
- **定义**：一个操作或多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
- **实现机制**：
  1. synchronized关键字
  2. Lock接口
  3. CAS操作
  4. Atomic包中的原子类

### 3.2 可见性（Visibility）
- **定义**：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
- **实现机制**：
  1. volatile关键字
  2. synchronized关键字
  3. final关键字
  4. Lock接口

### 3.3 有序性（Ordering）
- **定义**：程序执行的顺序按照代码的先后顺序执行
- **实现机制**：
  1. volatile关键字
  2. synchronized关键字
  3. Lock接口
  4. happens-before规则

## 四、happens-before规则

### 4.1 基本规则
1. **程序顺序规则**：一个线程中的每个操作，happens-before于该线程中的任意后续操作
2. **监视器锁规则**：对一个锁的解锁，happens-before于随后对这个锁的加锁
3. **volatile变量规则**：对一个volatile域的写，happens-before于任意后续对这个volatile域的读
4. **传递性规则**：如果A happens-before B，且B happens-before C，那么A happens-before C
5. **线程启动规则**：Thread对象的start()方法happens-before于此线程的每一个动作
6. **线程终止规则**：线程中的所有操作都happens-before于此线程的终止检测
7. **线程中断规则**：对线程interrupt()方法的调用happens-before于被中断线程的代码检测到中断事件的发生
8. **对象终结规则**：一个对象的初始化完成happens-before于它的finalize()方法的开始

### 4.2 规则的实际应用
```java
// 程序顺序规则示例
int a = 1;  // 1
int b = 2;  // 2
int c = a + b;  // 3
// 1 happens-before 2, 2 happens-before 3

// volatile变量规则示例
volatile boolean flag = false;
int data = 0;
// 线程1
data = 1;  // 1
flag = true;  // 2
// 线程2
if (flag) {  // 3
    int temp = data;  // 4
}
// 2 happens-before 3, 所以1 happens-before 4
```

## 五、内存屏障

### 5.1 四种屏障类型
1. **LoadLoad屏障**：确保Load1数据的装载先于Load2及其后所有装载指令的装载
2. **StoreStore屏障**：确保Store1数据对其他处理器可见先于Store2及其后所有存储指令的存储
3. **LoadStore屏障**：确保Load1数据装载先于Store2及其后所有的存储指令刷新到内存
4. **StoreLoad屏障**：确保Store1数据对其他处理器变得可见先于Load2及其后所有装载指令的装载

### 5.2 volatile的内存屏障
- **写操作**：
  1. StoreStore屏障
  2. 写volatile变量
  3. StoreLoad屏障

- **读操作**：
  1. 读volatile变量
  2. LoadLoad屏障
  3. LoadStore屏障

## 六、实践建议

### 6.1 正确使用同步机制
1. 优先使用volatile：适用于一写多读的场景
2. 其次使用CAS：适用于竞争不激烈的场景
3. 最后使用synchronized：适用于竞争激烈的场景

### 6.2 避免常见问题
1. 避免双重检查锁定的错误实现
2. 正确使用volatile
3. 注意原子性和可见性的区别
4. 理解happens-before规则

### 6.3 性能优化
1. 减少锁粒度
2. 使用无锁数据结构
3. 避免不必要的volatile声明
4. 合理使用线程本地变量
